{"ast":null,"code":"/**\r\n * Defines the base URL for the API.\r\n * The default values is overridden by the `API_BASE_URL` environment variable.\r\n */\nconst API_BASE_URL = process.env.REACT_APP_API_BASE_URL || \"http://localhost:8080\";\n\n/**\r\n * Defines the default headers for these functions to work with `json-server`\r\n */\nconst headers = new Headers();\nheaders.append(\"Content-Type\", \"application/json\");\n\n/**\r\n * Removes the `cards` property from the deck so it is not accidentally saved with the deck.\r\n *\r\n * This function is NOT exported because it is not needed outside of this file.\r\n *\r\n * @param deck\r\n *  the deck instance\r\n * @returns {*}\r\n *  a copy of the deck instance with the `cards` property removed.\r\n */\nfunction stripCards(deck) {\n  const {\n    cards,\n    ...deckWithoutCards\n  } = deck;\n  return deckWithoutCards;\n}\n\n/**\r\n * Fetch `json` from the specified URL and handle error status codes and ignore `AbortError`s\r\n *\r\n * This function is NOT exported because it is not needed outside of this file.\r\n *\r\n * @param url\r\n *  the url for the requst.\r\n * @param options\r\n *  any options for fetch\r\n * @param onCancel\r\n *  default value returned if the fetch is cancelled.\r\n * @returns {Promise<Error|any>}\r\n *  a promise that resolves to the `json` data or an error.\r\n *  If the response is not in the 200 - 399 range the promise is rejected.\r\n */\n\nasync function fetchJson(url, options, onCancel) {\n  try {\n    const response = await fetch(url, options);\n    if (response.status < 200 || response.status > 399) {\n      throw new Error(`${response.status} - ${response.statusText}`);\n    }\n    if (response.status === 204) {\n      return null;\n    }\n    return await response.json();\n  } catch (error) {\n    if (error.name !== \"AbortError\") {\n      console.error(error.stack);\n      throw error;\n    }\n    return Promise.resolve(onCancel);\n  }\n}\n\n/**\r\n * Retrieves all existing decks.\r\n * @returns {Promise<[deck]>}\r\n *  a promise that resolves to a possibly empty array of decks saved in the database.\r\n */\nexport async function listDecks(signal) {\n  const url = `${API_BASE_URL}/decks?_embed=cards`;\n  return await fetchJson(url, {\n    signal\n  }, []);\n}\n\n/**\r\n * Saves deck to the database (public/data/db.json).\r\n * There is no validation done on the deck object, any object will be saved.\r\n * @param deck\r\n *  the deck to save, which must not have an `id` property\r\n * @param signal\r\n *  optional AbortController.signal\r\n * @returns {Promise<deck>}\r\n *  a promise that resolves the saved deck, which will now have an `id` property.\r\n */\nexport async function createDeck(deck, signal) {\n  const url = `${API_BASE_URL}/decks`;\n  const options = {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify(stripCards(deck)),\n    signal\n  };\n  return await fetchJson(url, options, {});\n}\n\n/**\r\n * Retrieves the deck with the specified `deckId`\r\n * @param deckId\r\n *  the `id` property matching the desired deck.\r\n * @param signal\r\n *  optional AbortController.signal\r\n * @returns {Promise<any>}\r\n *  a promise that resolves to the saved deck.\r\n */\nexport async function readDeck(deckId, signal) {\n  const url = `${API_BASE_URL}/decks/${deckId}?_embed=cards`;\n  return await fetchJson(url, {\n    signal\n  }, {});\n}\n\n/**\r\n * Updates an existing deck\r\n * @param updatedDeck\r\n *  the deck to save, which must have an `id` property.\r\n * @param signal\r\n *  optional AbortController.signal\r\n * @returns {Promise<Error|*>}\r\n *  a promise that resolves to the updated deck.\r\n */\nexport async function updateDeck(updatedDeck, signal) {\n  const url = `${API_BASE_URL}/decks/${updatedDeck.id}?_embed=cards`;\n  const options = {\n    method: \"PUT\",\n    headers,\n    body: JSON.stringify(stripCards(updatedDeck)),\n    signal\n  };\n  return await fetchJson(url, options, updatedDeck);\n}\n\n/**\r\n * Deletes the deck with the specified `deckId`.\r\n * @param deckId\r\n *  the id of the deck to delete\r\n * @param signal\r\n *  optional AbortController.signal\r\n * @returns {Promise<Error|*>}\r\n *  a promise that resolves to an empty object.\r\n */\nexport async function deleteDeck(deckId, signal) {\n  const url = `${API_BASE_URL}/decks/${deckId}`;\n  const options = {\n    method: \"DELETE\",\n    signal\n  };\n  return await fetchJson(url, options);\n}\n\n/**\r\n * Creates a new card associated with the specified `deckId`.\r\n * There is no validation that there is an existing deck with the specified `deckId`.\r\n * @param deckId\r\n *  the id of the target deck\r\n * @param card\r\n *  the card to create, which must not have an `id` property\r\n * @param signal\r\n *  optional AbortController.signal\r\n * @returns {Promise<Error|*>}\r\n *  a promise that resolves to the new card, which will have an `id` property.\r\n */\nexport async function createCard(deckId, card, signal) {\n  // There is a bug in json-server, if you post to /decks/:deckId/cards the associated deckId is a string\n  // and the card is not related to the deck because the data types of the ID's are different.\n  const url = `${API_BASE_URL}/cards`;\n  card.deckId = Number(deckId);\n  const options = {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify(card),\n    signal\n  };\n  return await fetchJson(url, options, card);\n}\n\n/**\r\n * Retrieves the card with the specified `cardId`\r\n * @param cardId\r\n *  the id of the target\r\n * @param signal\r\n *  optional AbortController.signal\r\n * @returns {Promise<Error|*>}\r\n *  a promise that resolves to the saved card.\r\n */\nexport async function readCard(cardId, signal) {\n  const url = `${API_BASE_URL}/cards/${cardId}`;\n  return await fetchJson(url, {\n    signal\n  }, {});\n}\n\n/**\r\n * Updates an existing deck\r\n * @param updatedCard\r\n *  the card to save, which must have an `id` property.\r\n * @param signal\r\n *  optional AbortController.signal\r\n * @returns {Promise<Error|*>}\r\n *  a promise that resolves to the updated card.\r\n */\nexport async function updateCard(updatedCard, signal) {\n  const url = `${API_BASE_URL}/cards/${updatedCard.id}`;\n  const options = {\n    method: \"PUT\",\n    headers,\n    body: JSON.stringify(updatedCard)\n  };\n  return await fetchJson(url, options, updatedCard);\n}\n\n/**\r\n * Deletes the card with the specified `cardId`.\r\n * @param cardId\r\n *  the id of the card to delete\r\n * @param signal\r\n *  optional AbortController.signal\r\n * @returns {Promise<Error|*>}\r\n *  a promise that resolves to an empty object.\r\n */\nexport async function deleteCard(cardId, signal) {\n  const url = `${API_BASE_URL}/cards/${cardId}`;\n  const options = {\n    method: \"DELETE\",\n    signal\n  };\n  return await fetchJson(url, options);\n}","map":{"version":3,"names":["API_BASE_URL","process","env","REACT_APP_API_BASE_URL","headers","Headers","append","stripCards","deck","cards","deckWithoutCards","fetchJson","url","options","onCancel","response","fetch","status","Error","statusText","json","error","name","console","stack","Promise","resolve","listDecks","signal","createDeck","method","body","JSON","stringify","readDeck","deckId","updateDeck","updatedDeck","id","deleteDeck","createCard","card","Number","readCard","cardId","updateCard","updatedCard","deleteCard"],"sources":["C:/Users/bount/Documents/GitHub/Thinkful-Flashcard-App/src/utils/api/index.js"],"sourcesContent":["/**\r\n * Defines the base URL for the API.\r\n * The default values is overridden by the `API_BASE_URL` environment variable.\r\n */\r\n const API_BASE_URL = process.env.REACT_APP_API_BASE_URL || \"http://localhost:8080\";\r\n\r\n\r\n/**\r\n * Defines the default headers for these functions to work with `json-server`\r\n */\r\nconst headers = new Headers();\r\nheaders.append(\"Content-Type\", \"application/json\");\r\n\r\n/**\r\n * Removes the `cards` property from the deck so it is not accidentally saved with the deck.\r\n *\r\n * This function is NOT exported because it is not needed outside of this file.\r\n *\r\n * @param deck\r\n *  the deck instance\r\n * @returns {*}\r\n *  a copy of the deck instance with the `cards` property removed.\r\n */\r\nfunction stripCards(deck) {\r\n  const { cards, ...deckWithoutCards } = deck;\r\n  return deckWithoutCards;\r\n}\r\n\r\n/**\r\n * Fetch `json` from the specified URL and handle error status codes and ignore `AbortError`s\r\n *\r\n * This function is NOT exported because it is not needed outside of this file.\r\n *\r\n * @param url\r\n *  the url for the requst.\r\n * @param options\r\n *  any options for fetch\r\n * @param onCancel\r\n *  default value returned if the fetch is cancelled.\r\n * @returns {Promise<Error|any>}\r\n *  a promise that resolves to the `json` data or an error.\r\n *  If the response is not in the 200 - 399 range the promise is rejected.\r\n */\r\n\r\nasync function fetchJson(url, options, onCancel) {\r\n  try {\r\n    const response = await fetch(url, options);\r\n\r\n    if (response.status < 200 || response.status > 399) {\r\n      throw new Error(`${response.status} - ${response.statusText}`);\r\n    }\r\n\r\n    if (response.status === 204) {\r\n      return null;\r\n    }\r\n\r\n    return await response.json();\r\n\r\n  } catch (error) {\r\n    if (error.name !== \"AbortError\") {\r\n      console.error(error.stack);\r\n      throw error;\r\n    }\r\n    return Promise.resolve(onCancel);\r\n  }\r\n}\r\n\r\n/**\r\n * Retrieves all existing decks.\r\n * @returns {Promise<[deck]>}\r\n *  a promise that resolves to a possibly empty array of decks saved in the database.\r\n */\r\nexport async function listDecks(signal) {\r\n  const url = `${API_BASE_URL}/decks?_embed=cards`;\r\n  return await fetchJson(url, { signal }, []);\r\n}\r\n\r\n/**\r\n * Saves deck to the database (public/data/db.json).\r\n * There is no validation done on the deck object, any object will be saved.\r\n * @param deck\r\n *  the deck to save, which must not have an `id` property\r\n * @param signal\r\n *  optional AbortController.signal\r\n * @returns {Promise<deck>}\r\n *  a promise that resolves the saved deck, which will now have an `id` property.\r\n */\r\nexport async function createDeck(deck, signal) {\r\n  const url = `${API_BASE_URL}/decks`;\r\n  const options = {\r\n    method: \"POST\",\r\n    headers,\r\n    body: JSON.stringify(stripCards(deck)),\r\n    signal,\r\n  };\r\n  return await fetchJson(url, options, {});\r\n}\r\n\r\n/**\r\n * Retrieves the deck with the specified `deckId`\r\n * @param deckId\r\n *  the `id` property matching the desired deck.\r\n * @param signal\r\n *  optional AbortController.signal\r\n * @returns {Promise<any>}\r\n *  a promise that resolves to the saved deck.\r\n */\r\nexport async function readDeck(deckId, signal) {\r\n  const url = `${API_BASE_URL}/decks/${deckId}?_embed=cards`;\r\n  return await fetchJson(url, { signal }, {});\r\n}\r\n\r\n/**\r\n * Updates an existing deck\r\n * @param updatedDeck\r\n *  the deck to save, which must have an `id` property.\r\n * @param signal\r\n *  optional AbortController.signal\r\n * @returns {Promise<Error|*>}\r\n *  a promise that resolves to the updated deck.\r\n */\r\nexport async function updateDeck(updatedDeck, signal) {\r\n  const url = `${API_BASE_URL}/decks/${updatedDeck.id}?_embed=cards`;\r\n  const options = {\r\n    method: \"PUT\",\r\n    headers,\r\n    body: JSON.stringify(stripCards(updatedDeck)),\r\n    signal,\r\n  };\r\n  return await fetchJson(url, options, updatedDeck);\r\n}\r\n\r\n/**\r\n * Deletes the deck with the specified `deckId`.\r\n * @param deckId\r\n *  the id of the deck to delete\r\n * @param signal\r\n *  optional AbortController.signal\r\n * @returns {Promise<Error|*>}\r\n *  a promise that resolves to an empty object.\r\n */\r\nexport async function deleteDeck(deckId, signal) {\r\n  const url = `${API_BASE_URL}/decks/${deckId}`;\r\n  const options = { method: \"DELETE\", signal };\r\n  return await fetchJson(url, options);\r\n}\r\n\r\n/**\r\n * Creates a new card associated with the specified `deckId`.\r\n * There is no validation that there is an existing deck with the specified `deckId`.\r\n * @param deckId\r\n *  the id of the target deck\r\n * @param card\r\n *  the card to create, which must not have an `id` property\r\n * @param signal\r\n *  optional AbortController.signal\r\n * @returns {Promise<Error|*>}\r\n *  a promise that resolves to the new card, which will have an `id` property.\r\n */\r\nexport async function createCard(deckId, card, signal) {\r\n  // There is a bug in json-server, if you post to /decks/:deckId/cards the associated deckId is a string\r\n  // and the card is not related to the deck because the data types of the ID's are different.\r\n  const url = `${API_BASE_URL}/cards`;\r\n  card.deckId = Number(deckId);\r\n  const options = {\r\n    method: \"POST\",\r\n    headers,\r\n    body: JSON.stringify(card),\r\n    signal,\r\n  };\r\n  return await fetchJson(url, options, card);\r\n}\r\n\r\n/**\r\n * Retrieves the card with the specified `cardId`\r\n * @param cardId\r\n *  the id of the target\r\n * @param signal\r\n *  optional AbortController.signal\r\n * @returns {Promise<Error|*>}\r\n *  a promise that resolves to the saved card.\r\n */\r\nexport async function readCard(cardId, signal) {\r\n  const url = `${API_BASE_URL}/cards/${cardId}`;\r\n  return await fetchJson(url, { signal }, {});\r\n}\r\n\r\n/**\r\n * Updates an existing deck\r\n * @param updatedCard\r\n *  the card to save, which must have an `id` property.\r\n * @param signal\r\n *  optional AbortController.signal\r\n * @returns {Promise<Error|*>}\r\n *  a promise that resolves to the updated card.\r\n */\r\nexport async function updateCard(updatedCard, signal) {\r\n  const url = `${API_BASE_URL}/cards/${updatedCard.id}`;\r\n  const options = {\r\n    method: \"PUT\",\r\n    headers,\r\n    body: JSON.stringify(updatedCard),\r\n  };\r\n  return await fetchJson(url, options, updatedCard);\r\n}\r\n\r\n/**\r\n * Deletes the card with the specified `cardId`.\r\n * @param cardId\r\n *  the id of the card to delete\r\n * @param signal\r\n *  optional AbortController.signal\r\n * @returns {Promise<Error|*>}\r\n *  a promise that resolves to an empty object.\r\n */\r\nexport async function deleteCard(cardId, signal) {\r\n  const url = `${API_BASE_URL}/cards/${cardId}`;\r\n  const options = { method: \"DELETE\", signal };\r\n  return await fetchJson(url, options);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}